# *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*# ** Copyright UCAR (c) 2016# ** University Corporation for Atmospheric Research(UCAR)# ** National Center for Atmospheric Research(NCAR)# ** Research Applications Laboratory(RAL)# ** P.O.Box 3000, Boulder, Colorado, 80307-3000, USA# ** 2016/4/27 10:00:00# *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*# --- Import Modules --- #import syssys.dont_write_bytecode = True                                                  # Do not write .pyc filesimport osimport shutilimport timeimport numpyimport refrom importlib import reloadimport arcpytry:    reload  # Python 2.7except NameError:    try:        from importlib import reload    # Python 3.4+    except ImportError:        from imp import reload          # Python 3.0 - 3.3# Specify import path and append to PATHconfigfile = '~/FastEddyInput.py'sys.path.insert(1,os.path.dirname(os.path.expanduser(configfile)))import FastEddyInput as fe                                              # Function script packaged with this toolboxreload(fe)import domainCreate as dCreload(dC)# Re-load the function script in case of script changes# --- End Import Modules --- ## --- Module Configurations --- #arcpy.env.overwriteOutput = True                                                # Allow overwriting of outputsif arcpy.CheckExtension("Spatial") == "Available":                              # Check if the Spatial Analyst extention is available    arcpy.CheckOutExtension("Spatial")                                          # Check out Spatial Analyst extention license    from arcpy.sa import *                                                      # Add Spatial Analyst functions into namespace# --- End Module Configurations --- ##variables used in the creation of surface data from lidar datacell_size = 1only_ground_plus_class_code = Falseclass_code = 6minimum_height = -5maximum_height = 3000processing_extent = Trueclassify_noise = Falselog_directory = Trueverbose = Trueclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "FastEddy Input Data Processing"        self.alias = ""        self.description = "This is a standalone ArcGIS geoprocessing toolbox for FastEddy."        # List of tool classes associated with this toolbox        self.tools = [CreateDomain,CreateSurface,ProjectAndClip,CreateBuildingHeight]class CreateDomain:  '''  Defines the FastEddy domain center, extent, and projection.  Optionally saves the vertices to a .csv.  '''  def __init__(self):    self.label = 'Step 1: Create FastEddy Domain'    self.description = ''    self.canRunInBackground = True    self.category = 'Processing'  def getParameterInfo(self):    '''Retrieve user parameters.'''# output geodatabase    param0 = arcpy.Parameter(      displayName='Output Geodatabase',      name='outputGdb',      datatype='DEDatasetType',      parameterType='Required',      direction='Input'    )    param0.value = r'C:\Users\lave\Workspaces\ArcGIS\Cincy\Cincy.gdb'# center latitude (degrees N)    param1 = arcpy.Parameter(      displayName='Center Latitude (\xb0N)',      name='centerLat',      datatype='GPDouble',      parameterType='Required',      direction='Input'    )    param1.value = 39.1031# center longitude (degrees E)    param2 = arcpy.Parameter(      displayName='Center Longitude (\xb0E)',      name='centerLon',      datatype='GPDouble',      parameterType='Required',      direction='Input'    )    param2.value = -84.5120# buffer/half-domain height    param3 = arcpy.Parameter(      displayName='Half-Domain Height',      name='domainHeight',      datatype='GPLinearUnit',      parameterType='Required',      direction='Input'    )    param3.value = '5 Kilometers'# buffer/half-domain width    param4 = arcpy.Parameter(      displayName='Half-Domain Width',      name='domainWidth',      datatype='GPLinearUnit',      parameterType='Required',      direction='Input'    )    param4.value = '5 Kilometers'# domain name    param5 = arcpy.Parameter(      displayName='Domain Name',      name='domainName',      datatype='GPString',      parameterType='Required',      direction='Input'    )    param5.value = 'Cincy'# option to save output to csv    param6 = arcpy.Parameter(      displayName='Save Bounds to CSV? (True or False)',      name='saveOpt',      datatype='GPString',      parameterType='Required',      direction='Input'    )    param6.value = 'True'    parameters = [param0, param1, param2, param3, param4, param5, param6]    return (parameters)  def isLicensed(self):    '''Set whether tool is licensed to execute.'''       return True  def updateParameters(self, parameters):    '''    Modify the values and properties of parameters before internal    validation is performed.  This method is called whenever a parameter    has been changed.    '''      return  def updateMessages(self, parameters):    '''    Modify the messages created by internal validation for each tool    parameter.  This method is called after internal validation.    '''        return  def execute(self, parameters, messages):    '''The source code of the tool.'''# store parameters as text    parameters = [x.valueAsText for x in parameters]# check that domain width and height are equal    if parameters[3] != parameters[4]:      dC.printMessage(f'Domain height must be equal to domain width')      return# create custom FastEddy spatial reference    dC.printMessage(f'Step 1: Create FastEddy LCC spatial reference...')    spatial_ref = dC.createSpatialReference(      parameters[1], parameters[2], parameters[5]    )    dC.printMessage(f'Step 1: Complete! Spatial reference created.')# create domain center feature class; populate with center point    dC.printMessage(f'Step 2: Create domain center...')    domain_center_fc = dC.domainCenter(      parameters[5], parameters[0], spatial_ref    )    dC.printMessage(f'Step 2: Complete! Domain center created.')# create domain bounds    dC.printMessage(f'Step 3: Create domain polygon.')    domain_polygon = dC.domainPolygon(      domain_center_fc, parameters[3], parameters[4],       parameters[5], parameters[0]    )    dC.printMessage(f'Step 3: Complete! Domain polygon created.')# calculate and save domain corners    dC.printMessage(f'Step 4: Calculate domain polygon vertices.')    domain_corners = dC.domainVertices(      domain_polygon, parameters[5], parameters[0], spatial_ref, parameters[6]    )    dC.printMessage(f'Step 4: Complete! Domain vertices calculated.')    dC.printMessage(f'Tool completed successfully. Exiting...')    returnclass CreateSurface(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Step 2: Create Building Surface from LiDAR"        self.description = ""        self.canRunInBackground = True        self.category = "Processing"    def getParameterInfo(self):        """Define parameter definitions"""               # LiDAR EXE from LidarTools        param0 = arcpy.Parameter(        displayName="LiDAR EXE Directory from LiDAR Tools",        name="laszip",        datatype="DEFolder",        parameterType="Required",        direction="Input")        param0.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\lidarTools\LAStools\bin"        # Directory of LAS files        param1 = arcpy.Parameter(        displayName="Directory where LAS data is stored",        name="inputLidarDir",        datatype="DEFolder",        parameterType="Required",        direction="Input")        param1.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\lidar"            # Output Directory        param3 = arcpy.Parameter(        displayName="Output Geodatabase to store surface data",        name="scratchDir",        datatype="DEDatasetType",        parameterType="Required",        direction="Input")        param3.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\data\scratch.gdb"        #name for the output lidar file        #lidarDataName = "frisco.lasd"  #new lidar data from merged datasets        param4 = arcpy.Parameter(        displayName="Output LiDAR (lasd) file",        name="lidarDataName",        datatype="DELasDataset",        parameterType="Required",        direction="Output")        param4.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\data\testing\test.lasd"        ##                #change this to the name of your domain        #domainName = "frisco"        param6 = arcpy.Parameter(        displayName="Input domain name",        name="domainName",        datatype="GPString",        parameterType="Required",        direction="Input")        param6.value = "Dallas"        		        parameters = [param0, param1, param3, param4, param6]        return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return       def execute(self, parameters, messages):        """The source code of the tool."""        laszipDir = parameters[0].valueAsText  #r"C:\Users\boehnert\Documents\projects\Dallas_Fall2021\3DBasemaps\BuildingHeights\lidarTools\LAStools\bin\laszip.exe"        laszip = os.path.join(laszipDir,"laszip.exe")        inputLidarDir = parameters[1].valueAsText  #r"C:\Users\boehnert\Documents\projects\Dallas_Fall2021\DallasProject\Dallas\Friscolidar\las"        fe.printMessages(arcpy,inputLidarDir)                scratchDir = parameters[2].valueAsText        lasdName =  parameters[3].valueAsText  #r"C:\Users\boehnert\Documents\projects\Dallas_Fall2021\DallasProject\Dallas\Friscolidar"        domainName = parameters[4].valueAsText                #convert las to lasd        fe.printMessages(arcpy, ['Begining processing on {0}'.format(time.ctime())])        out_las_dataset = fe.convertlas(arcpy,laszip,inputLidarDir,lasdName)        #creates a dem, dsm, and ndsm file from the las file        project_ws = scratchDir        output_elevation_raster = os.path.join(scratchDir, domainName)        lc_log_dir= True        verbose=False        in_memory_switch=False        # extract the elevation layers        dem, dsm, ndsm = fe.extract(arcpy,lc_lasd=out_las_dataset,lc_ws=project_ws,lc_cell_size=float(cell_size),lc_ground_classcode=only_ground_plus_class_code,                        lc_class_code=class_code,                        lc_output_elevation=output_elevation_raster,                        lc_minimum_height=minimum_height,                        lc_maximum_height=maximum_height,                        lc_processing_extent=processing_extent,                        lc_noise=classify_noise,                        lc_log_dir=log_directory,                        lc_debug=verbose,                        lc_memory_switch=in_memory_switch)        sr1 = arcpy.Describe (ndsm).spatialReference        sr2 = arcpy.Describe (dem).spatialReference        sr3 = arcpy.Describe (dsm).spatialReference        if (sr1.metersPerUnit == 1.0) : # it is in meters            fe.printMessages(arcpy, ['Lidar data is in meters'])        else:            outDivide = Divide(dem, 3.281)            outDivide.save(output_elevation_raster +"dtm_m")            outDivide2 = Divide(dsm, 3.281)            outDivide2.save(output_elevation_raster+"dsm_m")            outDivide3 = Divide(ndsm, 3.281)            outDivide3.save(output_elevation_raster+"ndsm_m")           ##    def postExecute(self, parameters):##        """This method takes place after outputs are processed and##        added to the display."""##        returnclass ProjectAndClip(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Step 4: Project, Clip  and Convert Data 2"        self.description = ""        self.canRunInBackground = True        self.category = "Processing"    def getParameterInfo(self):        """Define parameter definitions"""                # Building data        param0 = arcpy.Parameter(        displayName="Input Building Data",        name="buildingData",        datatype="DERasterDataset",        parameterType="Optional",        direction="Input")        param0.value = r"C:\Users\boehnert\Documents\projects\Dallas_2025\finalGrids.gdb\building_Dallas"        # NLCD data        param1 = arcpy.Parameter(        displayName="Input Land Cover Data",        name="lcData",        datatype="DERasterDataset",        parameterType="Optional",        direction="Input")        param1.value = r"C:\Users\boehnert\Documents\projects\Dallas_2025\finalGrids.gdb\NLCD_Dallas"            # Elevation Data        param2 = arcpy.Parameter(        displayName="Input Elevation Data",        name="elevationData",        datatype="DERasterDataset",        parameterType="Optional",        direction="Input")        param2.value = r"C:\Users\boehnert\Documents\projects\Dallas_2025\finalGrids.gdb\elevation_Dallas"       # Land Use        param3 = arcpy.Parameter(        displayName="Input Land Use Data",        name="luDAta",        datatype="DERasterDataset",        parameterType="Optional",        direction="Input")        #param3.value = r"C:\Users\boehnert\Documents\projects\FtCollins\FtCollins\finalGrids.gdb\elevation_FtCollins"        	# lat data        param10 = arcpy.Parameter(        displayName="Input Lat Data",        name="latData",        datatype="DERasterDataset",        parameterType="Optional",        direction="Input")        param10.value = r"C:\Users\boehnert\Documents\projects\Dallas_2025\finalGrids.gdb\lat_Dallas"            # lon Data        param11 = arcpy.Parameter(        displayName="Input Lon Data",        name="elevationData",        datatype="DERasterDataset",        parameterType="Optional",        direction="Input")        param11.value = r"C:\Users\boehnert\Documents\projects\Dallas_2025\finalGrids.gdb\lon_Dallas"        #Domain file        param4 = arcpy.Parameter(        displayName="Input domain file",        name="domain",        datatype="GPFeatureLayer",        parameterType="Required",        direction="Input")        param4.value = r"C:\Users\boehnert\Documents\projects\FtCollins\FtCollins\finalGrids.gdb\FtCollins_FE_domain_FtCollins"               #domain name        param5 = arcpy.Parameter(        displayName="Input domain name",        name="domainName",        datatype="GPString",        parameterType="Required",        direction="Input")        param5.value = "FtCollins_test"                #projection dataset        param6 = arcpy.Parameter(        displayName="Input projection file",        name="projection",        datatype="GPFeatureLayer",        parameterType="Optional",        direction="Input")		        param6.value = r"C:\Users\boehnert\Documents\projects\FtCollins\FtCollins\finalGrids.gdb\FtCollins_FE_domain_FtCollins"        #parameter for final directory for CSV	        param7 = arcpy.Parameter(        displayName="Final Output Directory",        name="finalDir",        datatype="DEFolder",        parameterType="Required",        direction="Input")                        param7.value = r"C:\Users\boehnert\Documents\projects\FtCollins\FtCollins\test"        #parameter for final directory for CSV	        param8 = arcpy.Parameter(        displayName="Scratch Output Directory",        name="scratchDir",        datatype="DEDatasetType",        parameterType="Required",        direction="Input")                        param8.value = r"C:\Users\boehnert\Documents\projects\FtCollins\FtCollins\scratch.gdb"        #par9meter for final directory for CSV	        param9 = arcpy.Parameter(        displayName="Geodatabase to story final Gridded Data",        name="finalOutDir",        datatype="DEFolder",        parameterType="Required",        direction="Input")                        param9.value = r"C:\Users\boehnert\Documents\projects\FtCollins\FtCollins\test.gdb"					        parameters = [param0, param1, param2,param3, param4, param5, param6, param7,param8,param9,param10,param11]        #        return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return       def execute(self, parameters, messages):        """The source code of the tool."""                building = parameters[0].valueAsText  #r"C:\Users\boehnert\Documents\projects\Dallas_Fall2021\3DBasemaps\BuildingHeights\lidarTools\LAStools\bin\laszip.exe"        nlcd = parameters[1].valueAsText        elevation = parameters[2].valueAsText        lu = parameters[3].valueAsText        lat = parameters[10].valueAsText        lon = parameters[11].valueAsText        domain =  parameters[4].valueAsText  #r"C:\Users\boehnert\Documents\projects\Dallas_Fall2021\DallasProject\Dallas\Friscolidar"        domainName =  parameters[5].valueAsText        projection = parameters[6].valueAsText        finalDir = parameters[7].valueAsText        scratchDir = parameters[8].valueAsText        dataOutDir = parameters[9].valueAsText               #Project all input data        fe.printMessages(arcpy, ['Begining processing on {0}'.format(time.ctime())])                domainProject = fe.projection(arcpy,domain,dataOutDir,projection,domainName)        domainRaster = os.path.join(dataOutDir,"rasterDomain")        arcpy.conversion.FeatureToRaster(domainProject, "OBJECTID", domainRaster, 1)        if building is not None :            buildingProject = fe.projectionRaster(arcpy,building,scratchDir,projection,domainName,"building")            buildingClip = fe.clipRaster(arcpy,finalDir,domainRaster,buildingProject,scratchDir,dataOutDir,domainProject,domainName,"building")        if nlcd is not None :            nlcdProject = fe.projectionRaster(arcpy,nlcd,scratchDir,projection,domainName,"nlcd")            nlcdClip = fe.clipRaster(arcpy,finalDir,domainRaster,nlcdProject,scratchDir,dataOutDir,domainProject,domainName, "nlcd")        if lu is not None :            luProject = fe.projectionRaster(arcpy,lu,scratchDir,projection,domainName,"landuse")            luClip = fe.clipRaster(arcpy,finalDir,domainRaster,luProject,scratchDir,dataOutDir,domainProject,domainName,"landuse")        if elevation is not None :            elevationProject = fe.projectionRaster(arcpy,elevation,scratchDir,projection,domainName,"elevation")            elevationClip = fe.clipRaster(arcpy,finalDir,domainRaster,elevationProject,scratchDir,dataOutDir,domainProject,domainName,"elevation")        if lat is not None :            latProject = fe.projectionRaster(arcpy,lat,scratchDir,projection,domainName,"lat")            latClip = fe.clipRaster(arcpy,finalDir,domainRaster,latProject,scratchDir,dataOutDir,domainProject,domainName,"lat")        if lon is not None :            lonProject = fe.projectionRaster(arcpy,lon,scratchDir,projection,domainName,"lon")            lonClip = fe.clipRaster(arcpy,finalDir,domainRaster,lonProject,scratchDir,dataOutDir,domainProject,domainName,"lon")        fe.domainCorners(arcpy, domainName,scratchDir, finalDir,projection,domainProject)        ##        buildingClip = fe.clipRaster(arcpy,finalDir,domainRaster,buildingProject,scratchDir,dataOutDir,domainProject,domainName,"building")##        nlcdClip = fe.clipRaster(arcpy,finalDir,domainRaster,nlcdProject,scratchDir,dataOutDir,domainProject,domainName, "nlcd")##        luClip = fe.clipRaster(arcpy,finalDir,domainRaster,luProject,scratchDir,dataOutDir,domainProject,domainName,"landuse")##        elevationClip = fe.clipRaster(arcpy,finalDir,domainRaster,elevationProject,scratchDir,dataOutDir,domainProject,domainName,"elevation")        ##    def execute(self, parameters, messages):##        """The source code of the tool."""##        ##        building = parameters[0].valueAsText  #r"C:\Users\boehnert\Documents\projects\Dallas_Fall2021\3DBasemaps\BuildingHeights\lidarTools\LAStools\bin\laszip.exe"##        nlcd = parameters[1].valueAsText##        elevation = parameters[2].valueAsText##        lu = parameters[3].valueAsText##        domain =  parameters[4].valueAsText  #r"C:\Users\boehnert\Documents\projects\Dallas_Fall2021\DallasProject\Dallas\Friscolidar"##        domainName =  parameters[5].valueAsText##        projection = parameters[6].valueAsText##        finalDir = parameters[7].valueAsText##        scratchDir = parameters[8].valueAsText##        dataOutDir = parameters[9].valueAsText##       ####        #Project all input data##        fe.printMessages(arcpy, ['Begining processing on {0}'.format(time.ctime())])##        ##        domainProject = fe.projection(arcpy,domain,dataOutDir,projection,domainName)##        domainRaster = os.path.join(dataOutDir,"rasterDomain")##        arcpy.conversion.FeatureToRaster(domainProject, "OBJECTID", domainRaster, 1)##        buildingProject = fe.projectionRaster(arcpy,building,scratchDir,projection,domainName,"building")##        nlcdProject = fe.projectionRaster(arcpy,nlcd,scratchDir,projection,domainName,"nlcd")##        luProject = fe.projectionRaster(arcpy,lu,scratchDir,projection,domainName,"landuse")##        elevationProject = fe.projectionRaster(arcpy,elevation,scratchDir,projection,domainName,"elevation")####        fe.domainCorners(arcpy, domainName,scratchDir, finalDir,projection,domainProject)##        ##        buildingClip = fe.clipRaster(arcpy,finalDir,domainRaster,buildingProject,scratchDir,dataOutDir,domainProject,domainName,"building")##        nlcdClip = fe.clipRaster(arcpy,finalDir,domainRaster,nlcdProject,scratchDir,dataOutDir,domainProject,domainName, "nlcd")##        luClip = fe.clipRaster(arcpy,finalDir,domainRaster,luProject,scratchDir,dataOutDir,domainProject,domainName,"landuse")##        elevationClip = fe.clipRaster(arcpy,finalDir,domainRaster,elevationProject,scratchDir,dataOutDir,domainProject,domainName,"elevation")####        class CreateBuildingHeight(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "Step 3: Add Height to Buildings"        self.description = ""        self.canRunInBackground = True        self.category = "Processing"    def getParameterInfo(self):        """Define parameter definitions"""        # Building data        surface = arcpy.Parameter(        displayName="Input Surface Data (data generated from step 1 - ndsm)",        name="surfaceData",        datatype="DERasterDataset",        parameterType="Optional",        direction="Input")        surface.value = r"C:\Users\boehnert\Desktop\BuildingHeights\data\out.gdb\DFW_ndsm"        # Building data        param0 = arcpy.Parameter(        displayName="Input Building Height Data",        name="buildingData",        datatype="DEFeatureClass",        parameterType="Optional",        direction="Input")        param0.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\data\input.gdb\buildings"                      #domain name        param1 = arcpy.Parameter(        displayName="Input domain name",        name="domainName",        datatype="GPString",        parameterType="Required",        direction="Input")        param1.value = "test"                #parameter for final directory for CSV	        param2 = arcpy.Parameter(        displayName="Final Output Directory (directory)",        name="finalDir",        datatype="DEFolder",        parameterType="Required",        direction="Input")                        param2.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\data\final"	#parameter for final directory for CSV	        param3 = arcpy.Parameter(        displayName="Output Projection File (found in input.gdb)",        name="projection",        datatype="DEFeatureClass",        parameterType="Required",        direction="Input")                        param3.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\data\input.gdb\projection"	#parameter for scratch directory	        param4 = arcpy.Parameter(        displayName="Scratch Directory",        name="sratchDir",        datatype="DEWorkspace",        parameterType="Required",        direction="Input")                        param4.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\data\scratch.gdb"        #parameter for scratch directory	        param5 = arcpy.Parameter(        displayName="Domain File",        name="domain",        datatype="DEFeatureClass",        parameterType="Required",        direction="Input")                        param5.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\data\input.gdb\Domain"        #parameter for scratch directory	        param6 = arcpy.Parameter(        displayName="Geodatabase to store final Gridded data",        name="finalOutData",        datatype="DEWorkspace",        parameterType="Required",        direction="Input")                        param6.value = r"C:\Users\boehnert\Documents\projects\FastEddy_Toolbox\ForEinara\data\finalGrids.gdb"			        parameters = [surface,param0, param1, param2,param3,param4,param5,param6]        return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return       def execute(self, parameters, messages):        """The source code of the tool."""        surface = parameters[0].valueAsText        building = parameters[1].valueAsText  #r"C:\Users\boehnert\Documents\projects\Dallas_Fall2021\3DBasemaps\BuildingHeights\lidarTools\LAStools\bin\laszip.exe"        domainName = parameters[2].valueAsText        outDir = parameters[3].valueAsText        projection = parameters[4].valueAsText        scratchDir = parameters[5].valueAsText        domain = parameters[6].valueAsText        finalOutData = parameters[7].valueAsText               #convert las to lasd        fe.printMessages(arcpy, ['Begining processing on {0}'.format(time.ctime())])                buildingProject = fe.projection(arcpy,building,scratchDir,projection,domainName)        surfaceProject = fe.projectionRaster(arcpy,surface,scratchDir,projection,domainName,"surface")        domainProject = fe.projection(arcpy,domain,scratchDir,projection,domainName)        fe.getHeights(arcpy,buildingProject,surfaceProject,finalOutData,domainName,domainProject)   ##    def postExecute(self, parameters):##        """This method takes place after outputs are processed and##        added to the display."""##        return